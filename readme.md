*Директивы* 


v-text
Принимает: string

Подробности:

Управляет текстовым содержимым элемента (textContent). Если вам нужно управлять только частью содержимого тега, используйте интерполяцию {{ Mustache }}.

Пример:

<span v-text="msg"></span>
<!-- то же, что -->
<span>{{msg}}</span>
См. также: Синтаксис шаблонов — интерполяции

v-html
Принимает: string

Подробности:

Управляет HTML-содержимым элемента (innerHTML). Обратите внимание, что содержимое вставляется как обычный HTML — то есть не компилируется как шаблон Vue. Не стоит организовывать вложенные шаблоны с помощью v-html, попробуйте лучше применить компоненты.

Динамический рендеринг произвольного HTML-кода на сайте — это очень опасная практика, легко приводящая к XSS-уязвимостям. Передавайте в v-html только содержимое, которому можно доверять, и никогда — необработанный пользовательский ввод.

В однофайловых компонентах scoped стили не будут применены к содержимому внутри v-html, потому что этот HTML не обрабатывается компилятором шаблонов Vue. Если вы хотите стилизовать содержимое v-html с помощью локального CSS, то вы можете вместо этого использовать CSS-модули или дополнительный глобальный элемент <style> с иной стратегией, такой как БЭМ.

Пример:

<div v-html="html"></div>
См. также: Синтаксис шаблонов — интерполяции

v-show
Принимает: any

Использование:

Переключает CSS-свойство display элемента, в зависимости от того, истинно ли указанное выражение.

При изменении состояния этой директивы вызываются анимации, заданные в transition.

См. также: Условный рендеринг — v-show

v-if
Принимает: any

Использование:

Осуществляет рендеринг элемента, только если передаваемое выражение истинно. При изменении значения выражения на противоположное, элемент и содержащиеся в нём компоненты и директивы уничтожаются/пересоздаются. Если элемент — <template>, вместо него будет отрендерено его содержимое.

Эта директива также запускает анимационные переходы при изменении условия.

При совместном использовании v-if и v-for, v-for имеет более высокий приоритет. Подробности на странице рендеринга списков.

См. также: Условный рендеринг — v-if

v-else
Не принимает какое-либо выражение

Ограничение: предыдущий элемент должен иметь директиву v-if или v-else-if.

Использование:

Определяет “блок else” для v-if или цепочки v-if/v-else-if.

<div v-if="Math.random() > 0.5">
  Сейчас меня видно
</div>
<div v-else>
  А сейчас — нет
</div>
См. также: Условный рендеринг — v-else

v-else-if
Добавлено в версии 2.1.0+

Ожидает: any

Ограничение: предшествующий элемент должен иметь v-if или v-else-if.

Использование:

Обозначает “блок else if” для v-if. Можно объединять в цепочки.

<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Не A/B/C
</div>
См. также: Условный рендеринг — v-else-if

v-for
Принимает: Array | Object | number | string

Использование:

Многократно рендерит элемент или блок шаблона, основываясь на переданных данных. Значение директивы должно следовать синтаксису alias in expression — в alias будет элемент текущей итерации:

<div v-for="item in items">
  {{ item.text }}
</div>
Кроме того, вы можете указать название для индекса (или ключа, если вы работаете с объектом):

<div v-for="(item, index) in items"></div>
<div v-for="(val, key) in object"></div>
<div v-for="(val, key, index) in object"></div>
По умолчанию v-for будет пытаться обновить элементы “на месте”, не перемещая их. Если вам нужно, чтобы элементы перемещались, сохраняя явную упорядоченность, укажите атрибут key:

<div v-for="item in items" :key="item.id">
  {{ item.text }}
</div>
При совместном использовании v-if и v-for, v-for имеет более высокий приоритет. Подробности на странице рендеринга списков.

Использование v-for подробно описано в секции руководства по ссылке ниже.

См. также:

Рендеринг списков
key
v-on
Сокращение: @

Принимает: Function | Inline-выражение | Object

Параметр: event

Модификаторы:

.stop — вызовет event.stopPropagation().
.prevent — вызовет event.preventDefault().
.capture — добавит подписку в режиме capture.
.self — вызовет обработчик только если событие возникло непосредственно на этом элементе.
.{keyCode | keyAlias} — вызывает обработчик только при нажатии определённой клавиши.
.native — подписаться на нативное событие на корневом элементе компонента.
.once — вызовет обработчик не больше одного раза.
.left - (2.2.0) вызов обработчика только по событию нажатия левой кнопки мыши.
.right - (2.2.0) вызов обработчика только по событию нажатия правой кнопки мыши.
.middle - (2.2.0) вызов обработчика только по событию нажатия средней кнопки мыши.
.passive - (2.3.0+) вызов обработчика события DOM с опцией { passive: true }.
Использование:

Прикрепляет к элементу подписчик события. Тип события указывается в параметре. Выражение может быть именем метода, inline-выражением или вовсе отсутствовать, если указан один или несколько модификаторов.

У обычного элемента можно подписаться только на нативные события DOM. У элемента компонента можно подписаться на пользовательские события, вызываемые этим дочерним компонентом.

При работе с нативными событиями DOM, метод получает нативное событие единственным аргументом. В inline-выражениях, можно получить к нему доступ с помощью $event: v-on:click="handle('ok', $event)".

Начиная с версии 2.4.0+, v-on также поддерживает привязку к объекту пар событие/обработчик без аргумента. Обратите внимание, что при использовании синтаксиса объекта не поддерживаются никакие модификаторы.

Пример:

<!-- обработчик метода -->
<button v-on:click="doThis"></button>

<!-- inline-выражение -->
<button v-on:click="doThat('hello', $event)"></button>

<!-- сокращённая запись -->
<button @click="doThis"></button>

<!-- модификатор stop propagation -->
<button @click.stop="doThis"></button>

<!-- модификатор prevent default -->
<button @click.prevent="doThis"></button>

<!-- модификатор prevent default без дополнительных действий -->
<form @submit.prevent></form>

<!-- цепочка из модификаторов -->
<button @click.stop.prevent="doThis"></button>

<!-- модификатор клавиши keyAlias -->
<input @keyup.enter="onEnter">

<!-- модификатор клавиши keyCode -->
<input @keyup.13="onEnter">

<!-- обработчик метода будет вызван не больше одного раза -->
<button v-on:click.once="doThis"></button>

<!-- синтаксис объекта (2.4.0+) -->
<button v-on="{ mousedown: doThis, mouseup: doThat }"></button>
Подписка на пользовательское событие в дочернем элементе (обработчик вызывается, когда дочерний элемент вызывает “my-event”):

<my-component @my-event="handleThis"></my-component>

<!-- inline-выражение -->
<my-component @my-event="handleThis(123, $event)"></my-component>

<!-- подписываемся на нативное событие в компоненте -->
<my-component @click.native="onClick"></my-component>
См. также:

Обработка событий
Компоненты — Отправка сообщений родителям с помощью событий
v-bind
Сокращение: :

Принимает: any (если указан параметр) | Object (если параметр не указан)

Параметр: attrOrProp (опционально)

Модификаторы:

.prop — используется для связывания в качестве DOM-свойства, а не атрибута (в чём разница?). Если тег является компонентом, то .prop будет устанавливать свойство на $el компонента.
.camel — (2.1.0+) преобразует имена атрибутов из kebab-case в camelCase.
.sync — (2.3.0+) синтаксический сахар, который будет преобразован в обработчик v-on для обновления связанного значения.
Использование:

Динамически связывает атрибуты тега или входной параметр компонента с выражением.

При использовании с атрибутами class и style поддерживает массивы и объекты в качестве значений. Подробнее это описано в соответствующем руководстве по ссылке ниже.

Для правильного связывания входного параметра компонента, тот должен быть корректно определён в дочернем компоненте.

Если аргумент не указан, связанное значение может быть содержащим пары имя-значение. Обратите внимание, что в этом случае атрибуты class и style не поддерживают массивы и объекты.

Пример:

<!-- связывание атрибута -->
<img v-bind:src="imageSrc">

<!-- сокращение -->
<img :src="imageSrc">

<!-- поддержка конкатенации строк -->
<img :src="'/path/to/images/' + fileName">

<!-- связывание CSS-класса -->
<div :class="{ red: isRed }"></div>
<div :class="[classA, classB]"></div>
<div :class="[classA, { classB: isB, classC: isC }]">

<!-- связывание локального стиля -->
<div :style="{ fontSize: size + 'px' }"></div>
<div :style="[styleObjectA, styleObjectB]"></div>

<!-- связывание с объектом, содержащим атрибуты -->
<div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>

<!-- связывание с атрибутами DOM при указании модификатора -->
<div v-bind:text-content.prop="text"></div>

<!-- связывание входного параметра. "prop" должен быть определён в my-component. -->
<my-component :prop="someThing"></my-component>

<!-- передача всех входных параметров компонента в child-component -->
<child-component v-bind="$props"></child-component>

<!-- XLink -->
<svg><a :xlink:special="foo"></a></svg>
Модификатор .camel позволяет перевод имени атрибута v-bind в camelCase при использовании DOM-шаблонов, например для атрибута viewBox SVG:

<svg :view-box.camel="viewBox"></svg>
В использовании .camel нет необходимости, если вы пользуетесь строковыми шаблонами или vue-loader/vueify.

См. также:

Работа с классами и стилями
Компоненты — Передача данных в дочерние компоненты через входные параметры
Компоненты — Модификатор .sync
v-model
Принимает: разное, в зависимости от типа форм или выходных данных компонентов

Используется только с:

<input>
<select>
<textarea>
компонентами
Модификаторы:

.lazy — подписаться на события change, а не input
.number — приводить введённую строку к числу
.trim — удалять пробелы в начале и в конце введённой строки
Использование:

Двусторонним образом связывает элемент ввода данных или компонент с переменной. Директива подробно описана в руководстве по ссылке ниже.

См. также:

Работа с формами
Компоненты — Использование v-model на компонентах
v-pre
Не принимает какое-либо выражение

Использование:

Пропустить компиляцию для этого элемента и всех его потомков. Вы можете использовать это для отображения необработанных тегов {{}}. Кроме того, пропуск большого количества элементов может ускорить компиляцию.

Пример:

<span v-pre>{{ эта часть не будет скомпилирована }}</span>
v-cloak
Не принимает какое-либо выражение

Использование:

Эта директива останется на элементе до тех пор, пока связанный с ним экземпляр Vue не закончит компиляцию. В сочетании с CSS-правилом [v-cloak] { display: none } этой директивой можно скрывать нескомпилированные шаблоны до тех пор, пока экземпляр Vue не будет готов.

Пример:

[v-cloak] {
  display: none;
}
<div v-cloak>
  {{ message }}
</div>
Элемент <div> не появится, пока компиляция не закончится.

v-once
Не принимает какое-либо выражение

Использование:

Однократно рендерит элемент или компонент. При повторном рендеринге он, а также все его потомки, рассматриваются как статический контент и пропускаются. Это поможет увеличить производительность обновлений.

<!-- одиночный элемент -->
<span v-once>Это никогда не изменится: {{msg}}</span>

<!-- элемент с потомком -->
<div v-once>
  <h1>comment</h1>
  <p>{{msg}}</p>
</div>

<!-- компонент -->
<my-component v-once :comment="msg"></my-component>

<!-- директива `v-for` -->
<ul>
  <li v-for="i in list" v-once>{{i}}</li>
</ul>
См. также:

Синтаксис шаблонов — интерполяции
Компоненты — дешёвые статические компоненты с v-once